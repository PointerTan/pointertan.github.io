<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>。what a PT day</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-03-11T08:49:01.653Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>PT</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>实现 Rxjs 中的 Observable</title>
    <link href="http://yoursite.com/2019/03/11/Observable/"/>
    <id>http://yoursite.com/2019/03/11/Observable/</id>
    <published>2019-03-11T07:27:00.000Z</published>
    <updated>2019-03-11T08:49:01.653Z</updated>
    
    <content type="html"><![CDATA[<p>平时工作中很多地方用到了Rxjs，最基础的用法是使用Observable.create方法创建一个可订阅的对象，然后使用subscribe和unsubscribe，进行订阅和取消订阅的操作，通知到观察者observer。对这个用法，我简单地实现了一个自己的版本。</p><a id="more"></a><h3 id="1、Rxjs的简单用法。"><a href="#1、Rxjs的简单用法。" class="headerlink" title="1、Rxjs的简单用法。"></a>1、Rxjs的简单用法。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Rx = <span class="built_in">require</span>(<span class="string">'rxjs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> printer = Rx.Observable.create(<span class="function"><span class="params">observer</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">const</span> timer = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        observer.next(<span class="string">`something-<span class="subst">$&#123;count&#125;</span>`</span>)</span><br><span class="line">        count++</span><br><span class="line">        <span class="keyword">if</span> (count === <span class="number">5</span>) clearInterval(timer)</span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">printer.subscribe(&#123;</span><br><span class="line">    next: <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(x)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面这段代码在printer被订阅之后，会每隔2秒打印出1个推送过来的消息，一共5个。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">something-0</span><br><span class="line">something-1</span><br><span class="line">something-2</span><br><span class="line">something-3</span><br><span class="line">something-4</span><br></pre></td></tr></table></figure><h3 id="2、代码实现V1。"><a href="#2、代码实现V1。" class="headerlink" title="2、代码实现V1。"></a>2、代码实现V1。</h3><p>根据上面的用法，我的自定义版本需要提供一个create方法和一个对应实例的subscribe方法，并实现观察者<br>observer的next方法。 </p><p>实现如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myObservable = (<span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> create = <span class="function"><span class="params">func</span> =&gt;</span> (&#123;</span><br><span class="line">        subscribe: <span class="function"><span class="params">observer</span> =&gt;</span> &#123;</span><br><span class="line">            func(observer)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> &#123; create &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></p><p>利用了闭包的特性来实现，这样我们就可以使用类似Rxjs的方式来调用这段代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myPrinter = myObservable.create(<span class="function"><span class="params">observer</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">const</span> timer = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        observer.next(<span class="string">`something-<span class="subst">$&#123;count&#125;</span>`</span>)</span><br><span class="line">        count++</span><br><span class="line">        <span class="keyword">if</span> (count === <span class="number">5</span>) clearInterval(timer)</span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">myPrinter.subscribe(&#123;</span><br><span class="line">    next: <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(x)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>结果也是跟Rxjs的调用结果相同</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">something-0</span><br><span class="line">something-1</span><br><span class="line">something-2</span><br><span class="line">something-3</span><br><span class="line">something-4</span><br></pre></td></tr></table></figure><h3 id="3、-代码实现V2"><a href="#3、-代码实现V2" class="headerlink" title="3、 代码实现V2"></a>3、 代码实现V2</h3><p>如何实现unsubscribe, 首先需要在 myObservable 里面增加一个 unsubscribe 的方法，然后在触发观察者的回调之前判断是否已经被取消了订阅。</p><p>myObservable v2:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myObservable = (<span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> startSub = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">const</span> create = <span class="function"><span class="params">func</span> =&gt;</span> (&#123;</span><br><span class="line">        subscribe: <span class="function"><span class="params">subObject</span> =&gt;</span> &#123;</span><br><span class="line">            startSub = <span class="literal">true</span></span><br><span class="line">            <span class="keyword">const</span> observer = <span class="function"><span class="params">observerIn</span> =&gt;</span> (&#123;</span><br><span class="line">                next: <span class="function"><span class="params">x</span> =&gt;</span> startSub ? observerIn.next(x) : _</span><br><span class="line">            &#125;)</span><br><span class="line">            func(observer(subObject))</span><br><span class="line">        &#125;,</span><br><span class="line">        unsubscribe: <span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line">            startSub = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> &#123; create &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>增加了一个 startSub 的变量，在 unsubscribe 之后， startSub 为false。 同时在调用 observer 的 next 前，增加对 startSub 的判断。</p><p>使用方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">myPrinter.subscribe(&#123;</span><br><span class="line">    next: <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(x)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    myPrinter.unsubscribe()</span><br><span class="line">&#125;, <span class="number">7000</span>);</span><br></pre></td></tr></table></figure><p>结果只会打印出3个推送过来的消息，因为7秒的时候，取消了订阅，此后观察者就收不到推送消息了。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">something-0</span><br><span class="line">something-1</span><br><span class="line">something-2</span><br></pre></td></tr></table></figure></p><h3 id="4、代码实现V3"><a href="#4、代码实现V3" class="headerlink" title="4、代码实现V3"></a>4、代码实现V3</h3><p>增加异常处理：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myObservable = (<span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> startSub = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">const</span> create = <span class="function"><span class="params">func</span> =&gt;</span> (&#123;</span><br><span class="line">        subscribe: <span class="function"><span class="params">subObject</span> =&gt;</span> &#123;</span><br><span class="line">            startSub = <span class="literal">true</span></span><br><span class="line">            <span class="keyword">const</span> observer = <span class="function"><span class="params">observerIn</span> =&gt;</span> (&#123;</span><br><span class="line">                next: <span class="function"><span class="params">x</span> =&gt;</span> startSub ? observerIn.next(x) : _,</span><br><span class="line">                error: <span class="function"><span class="params">x</span> =&gt;</span> startSub &amp;&amp; observerIn.error ? observerIn.error(x): _</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                func(observer(subObject))</span><br><span class="line">            &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                observer(subObject).error(error)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        unsubscribe: <span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line">            startSub = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> &#123; create &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>对应的使用方法是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">myPrinter.subscribe(&#123;</span><br><span class="line">    next: <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(x),</span><br><span class="line">    error: <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'print error'</span>, x)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这个时候，如果 create 的方法执行中遇到错误抛出，就可以从观察者这里得到错误信息</p><p>比如 create 时抛出一个异常。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myPrinter = myObservable.create(<span class="function"><span class="params">o</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'外部方法出现错误'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>然后在对应的 myPrinter.subscribe 方法中就会得到通知：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">print error Error: 外部方法出现错误</span><br><span class="line">    at myObservable<span class="selector-class">.create</span><span class="selector-class">.o</span> (/Users/dingfan/xxx/xxx/test<span class="selector-class">.js</span>:<span class="number">71</span>:<span class="number">11</span>)</span><br><span class="line">    at Object<span class="selector-class">.subscribe</span> (/Users/dingfan/xxx/xxx/test<span class="selector-class">.js</span>:<span class="number">58</span>:<span class="number">17</span>)</span><br><span class="line">    at Object.&lt;anonymous&gt; (/Users/dingfan/xxx/xxx/test<span class="selector-class">.js</span>:<span class="number">80</span>:<span class="number">11</span>)</span><br></pre></td></tr></table></figure><h3 id="5、TODO"><a href="#5、TODO" class="headerlink" title="5、TODO"></a>5、TODO</h3><p>上面只是一个对 Rxjs Observable 的一个简单实现，而实际上这个框架有太多其他复杂的机制，observable 的实现远比这个复杂。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;平时工作中很多地方用到了Rxjs，最基础的用法是使用Observable.create方法创建一个可订阅的对象，然后使用subscribe和unsubscribe，进行订阅和取消订阅的操作，通知到观察者observer。对这个用法，我简单地实现了一个自己的版本。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JS" scheme="http://yoursite.com/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>吹水牛顿迭代法</title>
    <link href="http://yoursite.com/2017/05/24/%E5%90%B9%E6%B0%B4%E7%89%9B%E9%A1%BF%E8%BF%AD%E4%BB%A3%E6%B3%95/"/>
    <id>http://yoursite.com/2017/05/24/吹水牛顿迭代法/</id>
    <published>2017-05-24T15:50:03.000Z</published>
    <updated>2019-03-11T08:49:01.653Z</updated>
    
    <content type="html"><![CDATA[<p>因为吹水的能力不佳，所以要先打个草稿，今天的吹水过程大概是：<br>1、牛顿迭代法的演绎过程<br>2、牛顿迭代法求n次方根<br>3、牛顿迭代法求n次方根改进版<br>4、牛逼哄哄的invsqrt求平方根倒数</p><a id="more"></a><h3 id="1、牛顿迭代法的演绎过程"><a href="#1、牛顿迭代法的演绎过程" class="headerlink" title="1、牛顿迭代法的演绎过程"></a>1、牛顿迭代法的演绎过程</h3><p>乍一听，好像很高大上，其实理解上没什么难度。<br>牛顿迭代法就是在不断迭代的过程中逼近曲线的根，可以看做，它就是用来求曲线的根的。<br>所以它是怎么个迭代的过程，先上个动图：</p><p><img src="http://upload-images.jianshu.io/upload_images/145444-97bd4098731cb990.gif?imageMogr2/auto-orient/strip" alt="牛顿迭代法的过程"></p><p>我用吹水的姿势描述一遍动图的过程，先是有一个曲线，然后要找到曲线和x轴的交点，这个时候，脑袋一拍，选x1作为第一点，在这个点上垂直于x轴的线与曲线的交点，在这个交点做与曲线的切线，而切线与x轴的交点就是下一个迭代的点，不断重复这个过程，直到找到曲线和x轴交点这个目标值。值得注意的是，这个方法是不断逼近，所以得到的值可能会与目标值存在误差，而误差小于一定范围就可以认为是目标值了。一个更加图文并茂更加通俗易懂的解释可以点击 <a href="https://www.zhihu.com/question/20690553" target="_blank" rel="noopener">这个这个这个这个</a>。</p><h3 id="2、牛顿迭代法求n次方根"><a href="#2、牛顿迭代法求n次方根" class="headerlink" title="2、牛顿迭代法求n次方根"></a>2、牛顿迭代法求n次方根</h3><p>那为什么说牛顿迭代法能用来求n次根呢，其实在1中的目标值，即曲线与x轴相交点的x值，假设你的方程为 f(x) = x² - 64，当f(x) = 0时，x就是64的2次方根，以此类推，把2换成你想要求的n次方，就可以求出64的n次方根了。</p><p>明白了演绎过程，那我们就来探索它的代数实现。在上代码前，先上个图<br><img src="http://upload-images.jianshu.io/upload_images/145444-e4bfdc0c918f0b68.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="牛顿迭代法某一点的求值图解"></p><p>每次迭代要求的点就是右绿色箭头指向的这个点，在图中可以看到黑色箭头标识的线段长度为-f(x)，f’(x)是对f(x)的求导结果，也就是切线的斜率，所以绿色箭头线段的长度为-f(x)/f’(x)，而左绿色箭头的点为x，所有右绿色箭头指向的值为x加上绿色线段的长度，即x-(f(x)/f’(x))。</p><p>上面的代数实现完成后，就可以上代码了。嘻嘻嘻，最近在看<a href="http://composingprograms.com" target="_blank" rel="noopener">Python版的SICP</a>，所以贴上Python的代码，这篇文章也是因为看了这本书的1.6章节写的。def就是定义一个方法的意思。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">newton_nth_root_of_a</span><span class="params">(n, a, x = <span class="number">1</span>, e = <span class="number">1e-13</span>)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> x ** n - a</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">df</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> n * x ** (n - <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    gap = abs(f(x))</span><br><span class="line">    <span class="keyword">while</span> gap &gt; e:</span><br><span class="line">        x = x - f(x)/df(x)</span><br><span class="line">        gap = abs(f(x))</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">    </span><br><span class="line">print(newton_nth_root_of_a(<span class="number">1</span>, <span class="number">64</span>))  <span class="comment">#64.0</span></span><br><span class="line">print(newton_nth_root_of_a(<span class="number">2</span>, <span class="number">64</span>))  <span class="comment">#8.0</span></span><br><span class="line">print(newton_nth_root_of_a(<span class="number">3</span>, <span class="number">64</span>))  <span class="comment">#4.0</span></span><br><span class="line">print(newton_nth_root_of_a(<span class="number">4</span>, <span class="number">64</span>))  <span class="comment">#2.82842712474619</span></span><br><span class="line">print(newton_nth_root_of_a(<span class="number">5</span>, <span class="number">64</span>))  <span class="comment">#2.29739670999407</span></span><br><span class="line">print(newton_nth_root_of_a(<span class="number">6</span>, <span class="number">64</span>))  <span class="comment">#2.0</span></span><br></pre></td></tr></table></figure></p><p>这里是<a href="https://repl.it/IPMA/1" target="_blank" rel="noopener">在线可运行版本</a> ，不多不少，刚好十行，newton_nth_root_of_a方法定义中，n代表幂，a代表对a求根，x代表起始值，e代表误差范围，x和e已经设置了缺省值。f(x)是曲线，df(x)是f(x)的求导结果，在while循环中，x - f(x)/df(x)就是我们上面代数实现中的结果，直到f(x)的值小于误差，x就是最后的结果。</p><p>###3、牛顿迭代法求n次方根改进版<br>明白了1、2其实整个过程就是这样了，那为啥有3，因为要硬着头皮接着吹水😂。<br>2中的10行代码很简洁，但是假如我要不断的求某些值的2次根，就要不断调用newton_nth_root_of_a(2, a)。那么我们来改进下代码，保持上面的代码不变，增加下面的代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">curry_nth_root</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">curry_nth_root_of_a</span><span class="params">(a)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> newton_nth_root_of_a(n, a)    </span><br><span class="line">    <span class="keyword">return</span> curry_nth_root_of_a</span><br><span class="line"></span><br><span class="line">_2th_root = curry_nth_root(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">print(_2th_root(<span class="number">64</span>)) <span class="comment">#8.0</span></span><br><span class="line">print(_2th_root(<span class="number">49</span>)) <span class="comment">#7.000000000000001</span></span><br><span class="line">print(_2th_root(<span class="number">36</span>)) <span class="comment">#6.0</span></span><br><span class="line">print(_2th_root(<span class="number">25</span>)) <span class="comment">#5.0</span></span><br><span class="line">print(_2th_root(<span class="number">16</span>)) <span class="comment">#4.0</span></span><br><span class="line">print(_2th_root(<span class="number">9</span>))  <span class="comment">#3.0</span></span><br></pre></td></tr></table></figure></p><p>这里是<a href="https://repl.it/IPWo/0" target="_blank" rel="noopener">在线可运行版本</a> ，哇咔咔，在curry化之后，就可以方便的求n次方根了，不用每次都输入n。</p><p>curry化其实也很简单，那么我们就来个极端点的抽象代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">improve_guess</span><span class="params">(update, close, guess=<span class="number">1</span>)</span>:</span></span><br><span class="line">    <span class="string">'''返回猜想值，update为更新方法，close为逼近方法，guess为初始猜想值'''</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> close(guess):</span><br><span class="line">        guess = update(guess)</span><br><span class="line">    <span class="keyword">return</span> guess</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">newton_update</span><span class="params">(f, df)</span>:</span></span><br><span class="line">    <span class="string">'''返回牛顿迭代的计算函数, f为原函数，df是对其求导'''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> x - f(x) / df(x)</span><br><span class="line">    <span class="keyword">return</span> update</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">newton_find_zero_of_f</span><span class="params">(f, df, tolerance=<span class="number">1e-13</span>)</span>:</span></span><br><span class="line">    <span class="string">'''找出f(x)=0时，x的值，tolerance为与目标真实值的误差'''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">near_zero</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> is_eq(f(x), <span class="number">0</span>, tolerance)</span><br><span class="line">    <span class="keyword">return</span> improve_guess(newton_update(f, df), near_zero)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_eq</span><span class="params">(x, y, tolerance)</span>:</span></span><br><span class="line">    <span class="string">'''x与y的差值是否在误差范围内'''</span></span><br><span class="line">    <span class="keyword">return</span> abs(x - y) &lt; tolerance</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nth_root_of_a</span><span class="params">(n, a)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> x ** n - a</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">df</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> n * x ** (n - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> newton_find_zero_of_f(f, df)</span><br><span class="line">    </span><br><span class="line">print(nth_root_of_a(<span class="number">1</span>, <span class="number">64</span>))  <span class="comment">#64.0</span></span><br><span class="line">print(nth_root_of_a(<span class="number">2</span>, <span class="number">64</span>))  <span class="comment">#8.0</span></span><br><span class="line">print(nth_root_of_a(<span class="number">3</span>, <span class="number">64</span>))  <span class="comment">#4.0</span></span><br><span class="line">print(nth_root_of_a(<span class="number">4</span>, <span class="number">64</span>))  <span class="comment">#2.82842712474619</span></span><br><span class="line">print(nth_root_of_a(<span class="number">5</span>, <span class="number">64</span>))  <span class="comment">#2.29739670999407</span></span><br><span class="line">print(nth_root_of_a(<span class="number">6</span>, <span class="number">64</span>))  <span class="comment">#2.0</span></span><br></pre></td></tr></table></figure></p><p>这里是<a href="https://repl.it/IOMa/1" target="_blank" rel="noopener">在线可运行版本</a> ，把每一步都抽象出来，哈哈哈哈哈，这看上去很帅，虽然实际上没啥必要，最后也可以再curry化。这是个极端的例子，但是根据业务的需要，我们可以把需要复用的步骤抽象出来，而抽象的程度也要根据业务开展。</p><p>###4、牛逼哄哄的invsqrt求平方根倒数<br>吹水时间又到了，究竟这个牛顿迭代法有个毛线用。那你就要google下invsqrt这个改变游戏史进程的函数，可以看下知乎上的这个回答 <a href="https://zhihu.com/question/26934313/answer/37594577" target="_blank" rel="noopener">有哪些算法惊艳到了你？</a>。这个函数到底是干嘛的，就是求某个数的2次方根的倒数。因为这个函数在3d引擎的中经常使用，所以提高这个函数的效率是至关重要的，这个函数比系统的1/sqrt(x)快了一半。虽然是倒数，但是也是能用牛顿迭代法的啊。为毛啊，因为这也是曲线啊，过程跟1中的图相识。</p><p>但是！！！！请看代码<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">InvSqrt</span> <span class="params">(<span class="keyword">float</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> xhalf = <span class="number">0.5f</span>*x;</span><br><span class="line">    <span class="keyword">int</span> i = *(<span class="keyword">int</span>*)&amp;x;</span><br><span class="line">    i = <span class="number">0x5f3759df</span> - (i&gt;&gt;<span class="number">1</span>);</span><br><span class="line">    x = *(<span class="keyword">float</span>*)&amp;i;</span><br><span class="line">    x = x*(<span class="number">1.5f</span> - xhalf*x*x);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第六行就是利用牛顿迭代法的值x - f(x)/f’(x)演算后的结果，在这里f(x) = 1/x²，则f’(x)=2/x³。<br>第三行是把一个float指针强转成int指针，从而进行右移运算，因为float类型不能进行位运算，从而得到x值指数部分/2的结果，额，这里我不打算展开说啊，因为我说不清楚啊啊啊啊，我引用一段别人的解释，详情请移步<a href="https://www.zhihu.com/question/27455969/answer/94454251" target="_blank" rel="noopener">这里</a>：</p><blockquote><p>所以，32位的浮点数用十进制实数表示就是：M<em>2^E。开根然后倒数就是：M^(-1/2)</em>2^(-E/2)。现在就十分清晰了。语句i&gt; &gt;1其工作就是将指数除以2，实现2^(E/2)的部分。而前面用一个常数减去它，目的就是得到M^(1/2)同时反转所有指数的符号。</p></blockquote><p>至于0x5f3759df，这就相当无解了。<a href="https://zh.wikipedia.org/wiki/平方根倒数速算法" target="_blank" rel="noopener">wiki</a>的介绍中，这一句的注释是这样的：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i  = <span class="number">0x5f3759df</span> - ( i &gt;&gt; <span class="number">1</span> );               <span class="comment">// what the fuck?（这他妈的是怎么回事？）</span></span><br></pre></td></tr></table></figure></p><p>关于这个值后来也有人专门去推理过，还写成论文，但是，我肯定是看不懂的！！！<br>因为这一步，取到一个非常合适的初始值，只需要一次牛顿迭代就能知道目标值啦，一次！！！！</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>没有最后，今天吹水结束！！！！！！！！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为吹水的能力不佳，所以要先打个草稿，今天的吹水过程大概是：&lt;br&gt;1、牛顿迭代法的演绎过程&lt;br&gt;2、牛顿迭代法求n次方根&lt;br&gt;3、牛顿迭代法求n次方根改进版&lt;br&gt;4、牛逼哄哄的invsqrt求平方根倒数&lt;/p&gt;
    
    </summary>
    
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>Best Time to Buy and Sell Stock 系列算法题</title>
    <link href="http://yoursite.com/2017/04/17/Best%20Time%20to%20Buy%20and%20Sell%20Stock%20%E7%B3%BB%E5%88%97%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    <id>http://yoursite.com/2017/04/17/Best Time to Buy and Sell Stock 系列算法题/</id>
    <published>2017-04-17T15:04:03.000Z</published>
    <updated>2019-03-11T08:49:01.653Z</updated>
    
    <content type="html"><![CDATA[<p>这是最近在学算法中完成的第一个系列题，系列题的特点是后一道是前一道的升级版，后一道比前一道难，基本是一道比一道有意思，所以写一下总结是必须的呀。那为啥要重新学算法，大概是因为之前学得水吧。其实最近的计划是保持进阶学习的同时，不断地巩固基础，不断地进行精深练习。然后刚好遇到一个大神主播最近在讲算法，那就跟着学吧。</p><a id="more"></a><p>好了，今天的主角是LeetCode上的这几道题：<br>121    Best Time to Buy and Sell Stock<br>122    Best Time to Buy and Sell Stock II<br>123    Best Time to Buy and Sell Stock III<br>188    Best Time to Buy and Sell Stock IV<br>309    Best Time to Buy and Sell Stock with Cooldown   </p><p>其实主角是应该是动态规划，这类最佳xx的题目，一看就先想到动态规划。每一道题大概我都会写下我当时的思路，和怎么不通过，怎么改进，怎么优化。</p><h4 id="121-Best-Time-to-Buy-and-Sell-Stock"><a href="#121-Best-Time-to-Buy-and-Sell-Stock" class="headerlink" title="121 Best Time to Buy and Sell Stock"></a>121 Best Time to Buy and Sell Stock</h4><p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/#/description" target="_blank" rel="noopener">原题地址</a>。题目的意思大概是，给你一个股票的每天价格数组prices，你在只能进行一次操作（即一次买入和一次卖出）的限制下，求最大的收益。比如每天的价格为[7, 1, 5, 3, 6, 4]，那么最大收益就是1的时候买入，6的时候卖出，这样就能得到最大收益5。</p><p>第一步，明确下边界，当输入为空数组时，那最大收益就是0。而每天的价格，肯定是正数。</p><p>第二步，考虑不同的解决方案，这道题，用动态规划肯定是可以解的，然后其他方案，我也想不出来。<br>动态规划，先定义个dp[i]来表示第i天的最大收益，<br>dp[i] = prices[i] - prices[j]第j天买入的价格，因为交易只能有一次，所以，当买入卖出完成后，就能缓存当前结果了。<br>用swift来写的话，大概的递推过程如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxIncome = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span> ..&lt; prices.count &#123;</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span> ..&lt; i &#123;</span><br><span class="line">        <span class="keyword">if</span> prices[i] - prices[j] &gt; maxIncome &#123;</span><br><span class="line">            maxIncome = prices[i] - prices[j]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> maxIncome</span><br></pre></td></tr></table></figure></p><p>这样就能算出最大的收益了，不过如果把这段代码方式LeetCode上跑，结果是超时的。为啥呢？<br>额，在解释前，我说个LeetCode傻逼的地方，因为swift比较新吧，然后版本更迭又挺频繁的，所以swift的代码，LeetCode上很难保证其运行时间，比如说在同样时间复杂度的解题方案下，用JavaScript写的能过，用swift的不能过，额，真是坑爹。我被这个坑了几个小时，害我不断地优化代码，所以，虽然我是用swift来解题，但是有时候，我是用js复写了一遍swift的代码然后来提交的。<br>好了，上面这个解法为啥超时呢。。。根据经验，应该是重复计算的问题，但其实这里并没有重复计算，而是计算了很多本不需要计算的结果。第二个循环其实很多计算是不必要的，因为，我们要得出当前差值最大，那肯定是减去在i之前最小的值，而不需要去减i之前的每个数<br>所以，优化后，代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxIncome = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> minValue = Int.max</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span> ..&lt; prices.count &#123;</span><br><span class="line">    <span class="keyword">if</span> prices[i] &lt; minValue &#123;</span><br><span class="line">        minValue = prices[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> i &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> prices[i] - minValue &gt; maxIncome &#123;</span><br><span class="line">            maxIncome = prices[i] - minValue</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> maxIncome</span><br></pre></td></tr></table></figure></p><p>上面的两个方案，从复杂度来看，一个是O(n^2)，一个是O(n)，然后提交，accepted!!! </p><p>第三步，优化代码<br>其实这一步在第二步已经进行过一次了，即复杂度的优化，接下来就是一些小的优化，和代码风格的优化。<br>1、minValue的初始值可以为第一天的价格<br>2、在递推过程中，可以从第2天的开始，即i=1的时候。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxIncome = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> minValue = prices[i]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span> ..&lt; prices.count &#123;</span><br><span class="line">    <span class="keyword">if</span> prices[i] &lt; minValue &#123;</span><br><span class="line">        minValue = prices[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> prices[i] - minValue &gt; maxIncome &#123;</span><br><span class="line">        maxIncome = prices[i] - minValue</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> maxIncome</span><br></pre></td></tr></table></figure></p><p>上面的代码可以用三目运算符继续缩减行数的，不过，我觉得这样已经差不多了。ps，上面3段代码都是重新手打的，不保证通过啊。</p><h4 id="122-Best-Time-to-Buy-and-Sell-Stock-II"><a href="#122-Best-Time-to-Buy-and-Sell-Stock-II" class="headerlink" title="122 Best Time to Buy and Sell Stock II"></a>122 Best Time to Buy and Sell Stock II</h4><p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/#/description" target="_blank" rel="noopener">原题地址</a>。这道题是在上题的基础上，然后不限制交易次数，但是每次交易不能同时进行，即买入后要卖出才能进行下一次买入的操作。<br>第一道题已经把基本的、通用的结果步骤写出来了，我解题的时候大概也是遵循这样的步骤来解，所以第二题就不详细啰嗦的写了。<br>动态规划的第一步是给出状态的定义，在这道题中<br>我们这样来定义最大收益dp：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][<span class="number">0</span>]，dp[i][<span class="number">1</span>]代表 the i day, have or not stock，即第i天是否拥有股票哟，<span class="number">0</span>代表没有，<span class="number">1</span>代表当天持有股票。</span><br></pre></td></tr></table></figure></p><p>第二步是给出状态递推方程<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dp[i][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i])  </span><br><span class="line"><span class="comment">//即第i天没股票的最大收益，dp[i-1][0]代表前一天没有股票，dp[i-1][1]+prices[i]前一天有股票并卖出，而第i天的最大收益会是这两者之间的最大值。</span></span><br><span class="line">dp[i][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i], dp[i - <span class="number">1</span>][<span class="number">1</span>])  </span><br><span class="line"><span class="comment">//即第i天持有股票时的最大收益，dp[i-1][0]-prices[i]代表前一天没有股票并买入，dp[i-1][1]表示前一天持有股票的最大收益</span></span><br></pre></td></tr></table></figure></p><p>有了上面的递推方程，即dp[prices.count-1][0]，最后一天没有股票，就是当前的最大收益了。</p><p>其实这里可能大家会有疑惑，为啥dp要是二维数组，为什么一个为天数，一个为是否持股。额，其实，动态规划就是把每个因素转化为一个维度，这是标准的动态规划递推方程，每当有不同的决定因素时，往往可以通过增加维度来解题。但是增加维度的方式有多种，一位数组变成二维数组是一个方法，而增加不同的变量也是可以达到增加维度的效果的，如这里，你可以定义，s0[i],s1[i]分别为第i天没持股，和持股的最大收益。这样就不需要二维数组啦，但是方法的本质是一样。</p><p>代码如下（swift）：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func maxProfit(_ prices: [Int]) -&gt; Int &#123;</span><br><span class="line">    <span class="keyword">if</span> prices.count &lt;= <span class="number">1</span> &#123; <span class="keyword">return</span> <span class="number">0</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> dp: [[Int]] = <span class="built_in">Array</span>(repeating: [<span class="number">0</span>, <span class="number">0</span>], <span class="attr">count</span>: prices.count)</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span> ..&lt; prices.count  &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line">        dp[i][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i], dp[i - <span class="number">1</span>][<span class="number">1</span>])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[prices.count - <span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这道题还有个神奇的解法，不过跟动态规划没啥关系，我是看着别人代码写出来的😂，自行理解吧：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func maxProfit(_ prices: [Int]) -&gt; Int&#123;</span><br><span class="line">    <span class="keyword">var</span> max = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span> ..&lt; prices.count &#123;</span><br><span class="line">        <span class="keyword">if</span> prices[i] &gt; prices[i - <span class="number">1</span>] &#123;</span><br><span class="line">            max += prices[i] - prices[i - <span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Best-Time-to-Buy-and-Sell-Stock-III-和-IV"><a href="#Best-Time-to-Buy-and-Sell-Stock-III-和-IV" class="headerlink" title="Best Time to Buy and Sell Stock III 和 IV"></a>Best Time to Buy and Sell Stock III 和 IV</h4><p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/#/description" target="_blank" rel="noopener">原题III</a><br><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/#/description" target="_blank" rel="noopener">原题IV</a></p><p>第三题是限制次数两次，第四题是限制交易次数k次，在解第三题的时候，可以用一些方式，达到不增加维度的方式来解题，具体参照LeetCode讨论区里面的解法吧。而第四题是比第三题更加具有普遍性，上面说过，如果有新的决定因素，我们可以将它作为一个新的维度。即：<br>//dp[i][j][0]  dp[i][j][1]   the i day, have j transactions,  have or not stock<br>//dp[i][j][0] = max(dp[i - 1][j][0], dp[i - 1][j - 1][1] + prices[i])<br>//dp[i][j][1] = max(dp[i - 1][j][0] - prices[i], dp[i - 1][j][1])<br>第一行是状态定义，跟之前的定义类似，但是增加了一个维度，即第i天已经有j次交易是否持股的最大收益。<br>第二、第三行是状态转移方程，首先，买入股票并没有完成一次操作，而是在卖出之后，才会增加交易次数。所以能得出上面的两个方程。<br>代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">func maxProfit(_ k: Int, _ prices: [Int]) -&gt; Int &#123;</span><br><span class="line">    <span class="keyword">if</span> prices.count &lt;= <span class="number">1</span> &#123; <span class="keyword">return</span> <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> dp: [[[Int]]] = <span class="built_in">Array</span>(repeating: <span class="built_in">Array</span>(repeating: [Int.min, Int.min], <span class="attr">count</span>: k + <span class="number">1</span>), <span class="attr">count</span>: prices.count)</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> maxIncome = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span> ..&lt; prices.count  &#123;</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span> ... k &#123;</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> j &gt; <span class="number">0</span> &#123;</span><br><span class="line">                    dp[i][j][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][j][<span class="number">0</span>], dp[i - <span class="number">1</span>][j - <span class="number">1</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">                &#125;</span><br><span class="line">                dp[i][j][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][j][<span class="number">0</span>] - prices[i], dp[i - <span class="number">1</span>][j][<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">                maxIncome = max(maxIncome, dp[i][j][<span class="number">0</span>])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxIncome</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>maxIncome用来缓存j次交易后的最大收益，最后就是最大收益。上面的代码其实是不能通过, 但是这并不是重点。上面的代码大概就代表了整个解题的思路和递推过程。</p><p>假如理解了上面的代码，再来理解下面完整的代码，其实整体没啥变化，加了一些优化而已：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">func maxProfit(_ k: Int, _ prices: [Int]) -&gt; Int &#123;</span><br><span class="line">    <span class="keyword">if</span> prices.count &lt;= <span class="number">1</span> &#123; <span class="keyword">return</span> <span class="number">0</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> k &gt; prices.count / <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> maxIncomeK(prices)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> dp: [[[Int]]] = <span class="built_in">Array</span>(repeating: <span class="built_in">Array</span>(repeating: [Int.min, Int.min], <span class="attr">count</span>: k + <span class="number">1</span>), <span class="attr">count</span>: <span class="number">2</span>)</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> maxIncome = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span> ..&lt; prices.count  &#123;</span><br><span class="line">        <span class="keyword">let</span> x = i % <span class="number">2</span></span><br><span class="line">        <span class="keyword">let</span> y = (i - <span class="number">1</span>) % <span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span> ... k &#123;</span><br><span class="line">            <span class="keyword">if</span> j &gt; <span class="number">0</span> &#123;</span><br><span class="line">                dp[x][j][<span class="number">0</span>] = max(dp[y][j][<span class="number">0</span>], dp[y][j - <span class="number">1</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[x][j][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">            dp[x][j][<span class="number">1</span>] = max(dp[y][j][<span class="number">0</span>], dp[y][j][<span class="number">1</span>] + prices[i]) - prices[i] <span class="comment">//避免Int.min减去某个数，导致的溢出崩溃。</span></span><br><span class="line">            maxIncome = max(maxIncome, dp[x][j][<span class="number">0</span>])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxIncome</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func maxIncomeK(_ prices: [Int]) -&gt; Int&#123;</span><br><span class="line">    <span class="keyword">var</span> max = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span> ..&lt; prices.count &#123;</span><br><span class="line">        <span class="keyword">if</span> prices[i] &gt; prices[i - <span class="number">1</span>] &#123;</span><br><span class="line">            max += prices[i] - prices[i - <span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的代码变量名、方法名有些不是起得很合理，词穷啊，想名字好难。上面的代码对比之前的方案，差别在于：<br>1、当k &gt; prices.count / 2，这个时候就变回第二题了，这里的maxIncomK是第二题中那个神奇的解法。<br>其实完成上面这步处理，这道题就算完了，但是还有优化的地方，这里不能理解就略过吧，不过连我都能理解，应该没啥难度<br>2、状态压缩：var dp在定义的时候，第一维度只用来2个空间大小，而let x = i % 2和let y = (i - 1) % 2则是配套使用，额，其实本质是因为maxIncome用来缓存了当前的最大收益，所以这里可以不用那么多空间来存储，只需要用到这次跟上一次，这两个存储空间就够用了，这里属于空间复杂度的优化。<br>3、在递推过程里面，dp[x][j][1]的方程是不是有点奇怪，其实这是为了解决swift中Int.min减去某个数，导致的溢出崩溃。因为我们初始化的时候把每个值都初始化为Int.min。<br>好像没其他了，这道题就这样吧。</p><h4 id="309-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown"><a href="#309-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown" class="headerlink" title="309 Best Time to Buy and Sell Stock with Cooldown"></a>309 Best Time to Buy and Sell Stock with Cooldown</h4><p>这里每次交易完成后，必须冷静下，即至少暂停一天的操作，不能买不能卖，冷静一天都才有所决策。<br>这道题其实难度比3、4小，如果3、4都理解了，那么这道题就不难理解了。<br>下面给出我的解题方案（js）：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; prices</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxProfit = <span class="function"><span class="keyword">function</span>(<span class="params">prices</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (prices.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span> </span><br><span class="line">    <span class="keyword">var</span> dp = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">        dp[i] = []</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>]</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">2</span>] = <span class="built_in">Number</span>.MIN_VALUE</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; prices.length; i++)  &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="built_in">Math</span>.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>])</span><br><span class="line">        dp[i][<span class="number">1</span>] = <span class="built_in">Math</span>.max(dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i], dp[i - <span class="number">1</span>][<span class="number">1</span>])</span><br><span class="line">        dp[i][<span class="number">2</span>] = <span class="built_in">Math</span>.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.max(dp[prices.length - <span class="number">1</span>][<span class="number">0</span>], dp[prices.length - <span class="number">1</span>][<span class="number">2</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为啥我用了js来写，因为就是最前面说的LeetCode上swift抽风的问题。<br>dp[i][0] 表示第i天没有持股的最大收益<br>dp[i][1] 表示第i天有持股的最大收益<br>dp[i][2] 表示第i天没有持股，并且刚刚卖出了股票，如果是这个状态，那接下来就要冷静啦。即不能马上持股。</p><h4 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h4><p>这几道题目在写完之后确实收获不小，建议大家都亲手写一遍吖。</p><p>有人说算法没什么鸟蛋用，额，其实，写算法跟写业务差不多，好像这句我说过啊。<br>按我目前的理解，算法是进行精深练习的一个比较方便快捷的途径，不过也是比较原始的。但这能不断强化一些基本的代码能力，思考和抽象的能力吧。而且算法作为计算机的基础课程，对以后进阶有很大帮助吖。<br>上面这段我乱说的，大家自行理解吧。</p><p>还有一个，说到动态规划，我之前二话不说就是一个递归。但其实动态规划更应该用递推而不是递归。<br>所以以后看到动态规划的题，还是用递推吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是最近在学算法中完成的第一个系列题，系列题的特点是后一道是前一道的升级版，后一道比前一道难，基本是一道比一道有意思，所以写一下总结是必须的呀。那为啥要重新学算法，大概是因为之前学得水吧。其实最近的计划是保持进阶学习的同时，不断地巩固基础，不断地进行精深练习。然后刚好遇到一个大神主播最近在讲算法，那就跟着学吧。&lt;/p&gt;
    
    </summary>
    
      <category term="algorithm" scheme="http://yoursite.com/categories/algorithm/"/>
    
    
      <category term="算法, LeetCode, swift, 动态规划" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95-LeetCode-swift-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>使用reduce实现map和filter</title>
    <link href="http://yoursite.com/2017/04/15/%E4%BD%BF%E7%94%A8reduce%E5%AE%9E%E7%8E%B0map%E5%92%8Cfilter/"/>
    <id>http://yoursite.com/2017/04/15/使用reduce实现map和filter/</id>
    <published>2017-04-15T20:10:03.000Z</published>
    <updated>2019-03-11T08:49:01.653Z</updated>
    
    <content type="html"><![CDATA[<p>其实要拍脑袋直接写好像也不难。<br>但是还是尝试一步步分解地写下来，这样的话问题就更加有普遍性。<br>因为并不是所有问题都能一步到位地解决，重要的可能不是问题本身，而是解决问题的步骤和方式，这才是需要精深练习的地方。<br><a id="more"></a></p><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><h4 id="1、先写测试用例"><a href="#1、先写测试用例" class="headerlink" title="1、先写测试用例"></a>1、先写测试用例</h4><p>假设我自己实现的map函数名为ptxMap，假如ptxMap的结果和sdk实现的map方法返回结果是相同的，就可以认为成功啦。</p><p>testcase1:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> testArray = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> resultA = testArray.map() &#123; $<span class="number">0</span> * <span class="number">2</span> &#125;</span><br><span class="line"><span class="keyword">let</span> resultB = testArray.ptxMap() &#123; $<span class="number">0</span> * <span class="number">2</span> &#125;</span><br><span class="line">assert(resultA == resultB, <span class="string">"two results should equal"</span>)</span><br><span class="line"><span class="comment">//[2, 4, 6, 8, 10, 12, 14, 16, 18, 20]</span></span><br><span class="line"><span class="comment">//testcase1 fail</span></span><br></pre></td></tr></table></figure></p><h4 id="2、根据测试用例编写第一个版本的代码"><a href="#2、根据测试用例编写第一个版本的代码" class="headerlink" title="2、根据测试用例编写第一个版本的代码"></a>2、根据测试用例编写第一个版本的代码</h4><p>第一个可能觉得生涩的地方，是闭包作为参数传入。<br><a href="http://fuckingclosuresyntax.com" target="_blank" rel="noopener">关于闭包的语法介绍</a></p><p>其实可以认为闭包是一个匿名函数（虽然实际上在swift中Functions are a special case of closures）<br>然后本身作为高阶函数，map就是接收一个处理函数。</p><p>所以在定义ptxMap时，会传入一个dealFunc的闭包。<br>因为题目是用reduce来实现map，所以在方法体里调用Array的reduce方法，而reduce的处理函数在这里只是简单做一个往原始数组里面添加元素的操作。</p><p>第二个生涩的地方应该是swift的具体语法了，如通过self来调用reduce，还有尾部闭包的语法，然后因为Array本身支持泛型，所以append操作的时候需要转类型。</p><p>这样，第一个版本的ptxMap就完成了，测试用例1也能满足。</p><p>version one:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">extension <span class="built_in">Array</span> &#123;</span><br><span class="line">    func ptxMap(_ dealFunc: (Int) -&gt; Int) -&gt; [Int] &#123;</span><br><span class="line">        <span class="keyword">return</span> self.reduce([]) &#123; (result, element) -&gt; [Int] <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">var</span> tempResult = result</span><br><span class="line">            tempResult.append(dealFunc(element <span class="keyword">as</span>! Int))</span><br><span class="line">            <span class="keyword">return</span> tempResult</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//testcase1 succeed</span></span><br></pre></td></tr></table></figure></p><h4 id="3、添加测试用例，测试可能会失败"><a href="#3、添加测试用例，测试可能会失败" class="headerlink" title="3、添加测试用例，测试可能会失败"></a>3、添加测试用例，测试可能会失败</h4><p>平时写代码的时候，虽然先写了一些测试场景，并且也通过了。<br>但是写着写着，可能就想到新的测试用例了。<br>testcase1，输出为[Int]类型，所以ptxMap的返回类型也被写死了。<br>所以这个时候会想到假如输出的类型是由处理闭包决定的呢？<br>比如下面的testcase2，闭包返回String，ptxMap的返回类型应该为[String]，此时testcase2肯定不能通过测试，那就改代码呗。</p><p>testcase2:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> resultA = testArray.map() &#123; <span class="string">"\($0)"</span> &#125;</span><br><span class="line"><span class="keyword">let</span> resultB = testArray.ptxMap() &#123; <span class="string">"\($0)"</span> &#125;</span><br><span class="line">assert(resultA == resultB, <span class="string">"two results should equal"</span>)</span><br><span class="line"><span class="comment">//["1", "2", "3", "4", "5", "6", "7", "8", "9", "10"]</span></span><br><span class="line"><span class="comment">//testcase2 fail</span></span><br></pre></td></tr></table></figure></p><h4 id="4、改进程序"><a href="#4、改进程序" class="headerlink" title="4、改进程序"></a>4、改进程序</h4><p>既然要满足不同类型的返回，那么有两个方法：<br>1、函数重载。函数名相同的情况下，参数类型不同。<br>2、泛型。<br>如果选择第一种方法，那么返回类型就是有限的，而选择第二种方法，则能支持 满足当前泛型的类型约束的 所有类型<br>所以第二个版本是支持泛型的版本。</p><p>在ptxMap函数名后声明一个即将要用到的泛型类型T，代码如下。</p><p>version two:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">extension <span class="built_in">Array</span> &#123;</span><br><span class="line">    public func ptxMap&lt;T&gt;(_ dealFunc: (Element) -&gt; T) -&gt; [T] &#123;</span><br><span class="line">        <span class="keyword">return</span> self.reduce([]) &#123; (result, element) -&gt; [T] <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">var</span> tempResult = result</span><br><span class="line">            tempResult.append(dealFunc(element))</span><br><span class="line">            <span class="keyword">return</span> tempResult</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//testcase1 succeed</span></span><br><span class="line"><span class="comment">//testcase2 succeed</span></span><br></pre></td></tr></table></figure></p><p>这样，testcase2也满足了，其实这里的testcase并不完整，还应该添加一些边界的testcase，像空数组调用等。<br>好了，map的实现大概就这样了。</p><h4 id="延伸，闭包的调用方式"><a href="#延伸，闭包的调用方式" class="headerlink" title="延伸，闭包的调用方式"></a>延伸，闭包的调用方式</h4><p>在我们这个例子里，因为ptxMap的参数只有一个，并且为闭包，所以就使用下面这样方式调用，这也是比较建议的调用方式。<br>而后面这几种，则在这个例子中不太推荐。<br>其他情况参考<a href="https://github.com/raywenderlich/swift-style-guide#closure-expressions" target="_blank" rel="noopener">raywenderlich swift-style-guide</a></p><p>Preferred:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">testArray.ptxMap &#123; $<span class="number">0</span> * <span class="number">2</span> &#125;</span><br></pre></td></tr></table></figure></p><p>Not Preferred:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">testArray.ptxMap() &#123; $<span class="number">0</span> * <span class="number">2</span> &#125; </span><br><span class="line">testArray.ptxMap(&#123; (value) -&gt; Int <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> value * <span class="number">2</span></span><br><span class="line">&#125;)</span><br><span class="line">testArray.ptxMap(&#123; $<span class="number">0</span> * <span class="number">2</span> &#125;)</span><br></pre></td></tr></table></figure></p><h3 id="Filter和完整代码"><a href="#Filter和完整代码" class="headerlink" title="Filter和完整代码"></a>Filter和完整代码</h3><p>下面的代码实现了ptxFilter，因为filter并不涉及到输出类型的变化，所以并没有用到泛型。<br>下面是完整的代码，测试用例使用了do{}的方式，目的是隔离每个测试用例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> testArray = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line"></span><br><span class="line">extension <span class="built_in">Array</span> &#123;</span><br><span class="line">    public func ptxMap&lt;T&gt;(_ dealFunc: (Element) -&gt; T) -&gt; [T] &#123;</span><br><span class="line">        <span class="keyword">return</span> self.reduce([]) &#123; (result, element) -&gt; [T] <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">var</span> tempResult = result</span><br><span class="line">            tempResult.append(dealFunc(element))</span><br><span class="line">            <span class="keyword">return</span> tempResult</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public func ptxFilter(_ dealFunc: (Element) -&gt; Bool) -&gt; [Element] &#123;</span><br><span class="line">        <span class="keyword">return</span> self.reduce([]) &#123; (result, element) -&gt; [Element] <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">var</span> tempResult = result</span><br><span class="line">            <span class="keyword">if</span> dealFunc(element) &#123;</span><br><span class="line">                tempResult.append(element)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> tempResult</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> resultA = testArray.map &#123; $<span class="number">0</span> * <span class="number">2</span> &#125;</span><br><span class="line">    <span class="keyword">let</span> resultB = testArray.ptxMap &#123; $<span class="number">0</span> * <span class="number">2</span> &#125;</span><br><span class="line">    assert(resultA == resultB, <span class="string">"two results should equal"</span>)</span><br><span class="line">    print(resultB)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> resultA = testArray.map &#123; <span class="string">"\($0)"</span> &#125;</span><br><span class="line">    <span class="keyword">let</span> resultB = testArray.ptxMap &#123; <span class="string">"\($0)"</span> &#125;</span><br><span class="line">    assert(resultA == resultB, <span class="string">"two results should equal"</span>)</span><br><span class="line">    print(resultB)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> resultA = testArray.filter &#123; $<span class="number">0</span> % <span class="number">2</span> == <span class="number">0</span> &#125;</span><br><span class="line">    <span class="keyword">let</span> resultB = testArray.ptxFilter &#123; $<span class="number">0</span> % <span class="number">2</span> == <span class="number">0</span> &#125;</span><br><span class="line">    assert(resultA == resultB, <span class="string">"two results should equal"</span>)</span><br><span class="line">    print(resultB)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>额，为啥要蛋疼写总结呢<br>首先，在这里栽过跟头，然后，以后所有的学习结果都会用总结的方式来梳理一遍。</p><p>最近还在刷算法和数据结构，额，有一些主题大学的时候并没有涉及到，这次也算还回来了，后面再梳理下。<br>其实解题的时候方法也挺重要的，先明确，然后思考当前的所有方案，选择复杂度相对好的方案，实现，然后一步步优化。<br>这跟写业务的过程区别不大，所以，有时候需要注重解决问题的方法，因为这不仅仅适用于当前的问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实要拍脑袋直接写好像也不难。&lt;br&gt;但是还是尝试一步步分解地写下来，这样的话问题就更加有普遍性。&lt;br&gt;因为并不是所有问题都能一步到位地解决，重要的可能不是问题本身，而是解决问题的步骤和方式，这才是需要精深练习的地方。&lt;br&gt;
    
    </summary>
    
    
      <category term="swift, 编程, 闭包" scheme="http://yoursite.com/tags/swift-%E7%BC%96%E7%A8%8B-%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>推进工程化-api测试和自动测试</title>
    <link href="http://yoursite.com/2017/03/01/%E6%8E%A8%E8%BF%9B%E5%B7%A5%E7%A8%8B%E5%8C%96-api%E6%B5%8B%E8%AF%95%E5%92%8C%E8%87%AA%E5%8A%A8%E6%B5%8B%E8%AF%95/"/>
    <id>http://yoursite.com/2017/03/01/推进工程化-api测试和自动测试/</id>
    <published>2017-03-01T01:52:03.000Z</published>
    <updated>2019-03-11T08:49:01.653Z</updated>
    
    <content type="html"><![CDATA[<p>时间总是过得很快，快到我连自己写的代码都不记得，快到我都不知道我曾经做过什么</p><a id="more"></a><p>最近一周大概就在做这么一件事吧，node工程测试自动化。给现有的一个node工程加上了API测试，然后通过travis-ci实现测试自动化，在每次commit之后进行自动测试，travis会在测试失败的时候给你发邮件。</p><p>工程化的第一个环节，应该就是测试吧，测试的好处有很多，提高代码质量、提高工程质量、降低维护的时间、让你的代码更加有可读性、改起来也更加随心所欲，还有一个好处大家可能会觉得奇怪–节省时间。</p><p>比较典型的场景就是，修复了A Bug，却导致了B bug，如果测试覆盖到了，B bug就不会发生。再举一个场景，比如你加了一段你自己很有信心的代码，你总觉得这段代码肯定没问题，并且这段代码手动测试的话比较麻烦，要好几个步骤，所以你自信地说，可以了，没问题，额，然后就啪啪啪打脸，如果有代码测试，这打脸的机会就会少很多。</p><p>好吧，大家都知道测试很重要，但是很少人会去做，所以这是怎么一回事呢，我们来捋一下这个过程。</p><h4 id="什么样工程需要做测试？"><a href="#什么样工程需要做测试？" class="headerlink" title="什么样工程需要做测试？"></a>什么样工程需要做测试？</h4><p>只要不是一次性的工程，只要后面会有新需求的工程，都要加测试，大概就是说基本所有工程都得加测试，哈哈</p><h4 id="什么样的代码需要做测试？"><a href="#什么样的代码需要做测试？" class="headerlink" title="什么样的代码需要做测试？"></a>什么样的代码需要做测试？</h4><p>重要的出入口。 这是代码测试的粒度问题，这是我后面还需要学习的内容，但目前来说，我觉得重要的出入口是需要测试的，比如对后台来说，接口就是重要的出入口，所以这里需要覆盖测试。</p><h4 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h4><p>其实工具也不是必要的，但就目前的实践来看，mocha和chai是需要了解的两个工具</p><h4 id="阻碍大家实践测试的原因"><a href="#阻碍大家实践测试的原因" class="headerlink" title="阻碍大家实践测试的原因"></a>阻碍大家实践测试的原因</h4><p>第一个应该是开发模式的改变，不管是先写代码还是先写测试，但是这个怎么说的，有好的姿势干嘛不尝试呢？ 第二个原因是大家经常能听到的，浪费时间，工期紧……类似的，一堆。这里就是粒度的问题了，当你觉得浪费时间的时候，你可以只测试重要出入口。</p><h4 id="再说测试的好处"><a href="#再说测试的好处" class="headerlink" title="再说测试的好处"></a>再说测试的好处</h4><p>常听到的好处就不说了，说下代码可读性吧，加上测试，这段代码期待的输入输出就很清晰了，当你一个月之后来看自己代码，当别人需要看你代码，很快就能熟悉。 还有一个，节省时间，假设你写了一段代码，可能本来需要调接口来调试，也可能本来需要通过界面交互来调试，经常这个调试过程需要来回几次，如果这时覆盖了测试，可能之前的步骤只需要一次。 尤其调试是前后端不同人员之间的调试，界面调试是要点好几层交互的情况下，节省下来的时间也是不少的。</p><h4 id="成本和收获"><a href="#成本和收获" class="headerlink" title="成本和收获"></a>成本和收获</h4><p>任何事情都是有成本，在于你怎么考虑吧，学习新姿势当然有成本，但是考虑到这个新姿势带来的好处，嗯，学吧</p><h4 id="下一步"><a href="#下一步" class="headerlink" title="下一步"></a>下一步</h4><p>1、测试的粒度和团队实践。<br>2、给travis加上自动部署。<br>3、继续探索新姿势–review。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;时间总是过得很快，快到我连自己写的代码都不记得，快到我都不知道我曾经做过什么&lt;/p&gt;
    
    </summary>
    
    
      <category term="工程化, 自动测试, api测试" scheme="http://yoursite.com/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96-%E8%87%AA%E5%8A%A8%E6%B5%8B%E8%AF%95-api%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>使用第三方IDE开发微信小程序</title>
    <link href="http://yoursite.com/2016/12/13/%E4%BD%BF%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9IDE%E5%BC%80%E5%8F%91%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    <id>http://yoursite.com/2016/12/13/使用第三方IDE开发微信小程序/</id>
    <published>2016-12-13T16:07:00.000Z</published>
    <updated>2019-03-11T08:49:01.653Z</updated>
    
    <content type="html"><![CDATA[<p>昨天在朋友圈看到有前同事抱怨微信小程序的IDE经常崩溃，而我们团队在这两个多月的开发中并没被这个问题所困扰，所以就想着是不是可以分享下我们现在的开发流程，嗯，开始吧。额，不过开始前要申明，这套流程不是我的想法，而是我们的96小鲜肉的作品. 而我作为一枚常年奴役在Xcode下的iOSer，怎么可能敢对IDE有半点不敬呢。</p><a id="more"></a><h5 id="gulp"><a href="#gulp" class="headerlink" title="gulp"></a>gulp</h5><p>先介绍下gulp，不知道的童鞋github一下，看着24000+的star就知道是个好工具了（<a href="https://github.com/gulpjs/gulp" target="_blank" rel="noopener">github repo</a>）。gulp可以理解成是个预处理工具、构建工具之类的，并且提供各类插件。当然这个工具也有替代品，Grunt之类的。所以使用这个工具就可以使用你喜欢的IDE来码代码了，而小程序开发工具就可以全职当模拟器和调试器啦。感觉给前端科普gulp是在作死，谁会不知道，额，不过也可能不只前端在做小程序，比如我，此处手动微笑。</p><h5 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h5><p>简单地说，就是把工程中相应wxml、wxss分别替换成html和scss文件来开发，再利用gulp命令来预处理回之前的格式，然后在小程序开发工具进行预览和调试。下面再说说使用gulp构建小程序带来的好处</p><h5 id="html、scss-gt-wxml、wxss"><a href="#html、scss-gt-wxml、wxss" class="headerlink" title="html、scss=&gt;wxml、wxss"></a>html、scss=&gt;wxml、wxss</h5><p>增加这个步骤是为了让其他IDE能继续代码高亮、提示和格式化之类的，当然如果你是用文本编辑器来码代码，当我没说😂。当然，好处不只这一些，比如sass，sass可以理解为是css的一种拓展格式，在实践中最大的好处就是使样式具有层级关系，这样代码容易阅读和定位，还有更多更强大的功能，自行google咯。</p><h5 id="gulp-tools"><a href="#gulp-tools" class="headerlink" title="gulp tools"></a>gulp tools</h5><p>gulp作为一个强大的构建工具，提供了很多插件，比如你可以利用babel来实现es6转es5，虽然原生工具现在也支持了，你也可以让小的资源转成base64字符串，使用gulp还能更方便地切换测试和开发环境，也能方便地打包各个环境的代码，反正之前在web开发能做到的，这里基本都能做到。</p><h5 id="any-IDE"><a href="#any-IDE" class="headerlink" title="any IDE"></a>any IDE</h5><p>接下来，你就可以使用你喜欢的IDE，用你喜欢的各种姿势。我大部分时间都用vscode，支持插件，各种格式化选项，还有命令行工具，在终端目录下使用”code .”命令就能打开当前工程。</p><h5 id="全职模拟器"><a href="#全职模拟器" class="headerlink" title="全职模拟器"></a>全职模拟器</h5><p>当原生工具不再承担码代码的功能，我相信它也是快乐的。首先它崩溃的几率就少了很多，并且你可以把它放在第二个屏幕上或者你喜欢的任何地方，它肯定活得比现在轻松和快乐许多。当然你可能还是要承受一点损失，小程序原生api的代码提示功能，还有你码代码前，得跑下监听的命令。</p><h5 id="模版"><a href="#模版" class="headerlink" title="模版"></a>模版</h5><p>上面净说了一堆，我在自己的github上建了个<a href="https://github.com/PointerTan/MINA-Gulp-Template" target="_blank" rel="noopener">模板工程</a>，代码沿用我们之前的工程，具体用法请阅读README。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天在朋友圈看到有前同事抱怨微信小程序的IDE经常崩溃，而我们团队在这两个多月的开发中并没被这个问题所困扰，所以就想着是不是可以分享下我们现在的开发流程，嗯，开始吧。额，不过开始前要申明，这套流程不是我的想法，而是我们的96小鲜肉的作品. 而我作为一枚常年奴役在Xcode下的iOSer，怎么可能敢对IDE有半点不敬呢。&lt;/p&gt;
    
    </summary>
    
    
      <category term="IDE, 小程序, gulp" scheme="http://yoursite.com/tags/IDE-%E5%B0%8F%E7%A8%8B%E5%BA%8F-gulp/"/>
    
  </entry>
  
  <entry>
    <title>重复的命运</title>
    <link href="http://yoursite.com/2016/12/11/%E9%87%8D%E5%A4%8D%E7%9A%84%E5%91%BD%E8%BF%90/"/>
    <id>http://yoursite.com/2016/12/11/重复的命运/</id>
    <published>2016-12-11T08:06:00.000Z</published>
    <updated>2019-03-11T08:49:01.653Z</updated>
    
    <content type="html"><![CDATA[<p>命运在试探我，我该奋力反击还是缴械投降<br>the fate is testing me, should i get up or give up</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;命运在试探我，我该奋力反击还是缴械投降&lt;br&gt;the fate is testing me, should i get up or give up&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>一开始说要开发小程序，我内心是拒绝的（上）</title>
    <link href="http://yoursite.com/2016/10/04/%E4%B8%80%E5%BC%80%E5%A7%8B%E8%AF%B4%E8%A6%81%E5%BC%80%E5%8F%91%E5%B0%8F%E7%A8%8B%E5%BA%8F%EF%BC%8C%E6%88%91%E5%86%85%E5%BF%83%E6%98%AF%E6%8B%92%E7%BB%9D%E7%9A%84%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <id>http://yoursite.com/2016/10/04/一开始说要开发小程序，我内心是拒绝的（上）/</id>
    <published>2016-10-04T19:06:55.000Z</published>
    <updated>2019-03-11T08:49:01.653Z</updated>
    
    <content type="html"><![CDATA[<p>你不能说叫我开发我就开发，首先，我得看下文档😂</p><a id="more"></a><p>8月的时候开始跑全栈，学习web开发和node.js，中间突然出现了个微信小程序，一开始并不想理它，因为有苹果的存在，肯定不会让微信搞自己的应用市场，后来翻了翻小程序的开发文档，就更不想理它了，从技术的角度看，这是个很封闭的轮子，更何况我正处在一大波web开发的热情中😂😂</p><p>然而公司只有一个前端小鲜肉，而且任务都排满了，好吧，那我就浪费下生命先踩踩微信小程序的坑吧。一开始我就只想着踩踩坑、熟悉下开发流程，后来才知道公司产品已经决定向微信生态靠拢，并且拿到了内测资格，而且国庆就要捣鼓出可上线版本。。。后来被这白花花的流量引诱着，嗯，微信小程序确实是个机会。</p><p>看到设计图的时候我是崩溃的，复杂的界面意味着一大堆坑，后来发生的事情也证明了我直觉是对的🌚</p><p>好了，故事讲完了，接下来就是国庆只放假一天😂😂😂</p><p>其实国庆加班了3天，有些同事还加了4天，整个程序基本都做好了，剩下就是优化和调整啦，打算下一篇再记录下技术问题，因为要睡觉了，明天还要加班😂😂😂😂</p><p>————————分割线—————————— </p><p>有时候发现自己并不是多喜欢编程，不过编程倒也是一种探索世界的方式，如果每天都在学习，其实就相当于每天都在探索世界，而在编程的世界里，总有东西可以学习。当然，不能只学一些没味道的东西，例如微信小程序。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;你不能说叫我开发我就开发，首先，我得看下文档😂&lt;/p&gt;
    
    </summary>
    
    
      <category term="微信小程序" scheme="http://yoursite.com/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>七月上</title>
    <link href="http://yoursite.com/2016/07/24/%E4%B8%83%E6%9C%88%E4%B8%8A/"/>
    <id>http://yoursite.com/2016/07/24/七月上/</id>
    <published>2016-07-24T18:15:39.000Z</published>
    <updated>2019-03-11T08:49:01.653Z</updated>
    
    <content type="html"><![CDATA[<p>有一首挺喜欢的歌， <a href="http://music.163.com/#/m/song?id=31445554" target="_blank" rel="noopener">七月上</a>, 也刚好这个月是七月。</p><a id="more"></a><p>这是个漫长的月份，很多美好的事情，都触不及防地发生了。 先是一段充满大自然、略带些宗教气息的旅程，途中还看完了一本杂文集，算是感受了点文学气息，回来后又看了一本小说，一行行的文字，呈现着一幅幅画面。 回来后刚好公司又开启新的项目，每次的第一步都踏的如此艰难，尤其是我这么纠结的，当我要去复用过去的模块时，就忍不住想重新写一遍，越写越觉得以前的东西像坨屎。每个开始我都想它是个完美的开始，所以每个开始都是最揪心的，到底还是因为自己菜吧。</p><p>在某次逛知乎的时候，看到推荐的几本物理入门书籍，本着热爱生活（买买买）的原则，开始探索这神奇的世界–果壳中的宇宙。这里又要说一段很怂的事情，按道理理科生不该怕鬼，但不知为啥，黑夜中狂暴雷鸣、黑夜独自用吹风机、黑夜洗澡的时候，心里偶尔会发凉。奇怪的事情又发生了，看了这本开头几十页，这么害怕也慢慢消失了，记得有次半夜电闪雷鸣，我正在翻着小说，完全不会感到害怕。认识这个世界原来还有这种效果，但我心里总觉得是跟我去过塔尔寺有关系，那是一种很交织的感觉，首先我是尊重宗教信仰的，但见识过真正的宗教信仰，你不得不停下来思考这是多么可怕的力量，而对于我，信仰科学，这应该是我最终的宿命。</p><p>为了跑通全栈我开始学习web开发，只是跑通，同时也感受下js的强大，虽然进度不咋地，但我还是挺满意的，毕竟慢点学好过不学对吧。这也是我对待事情的一个改变吧，之前对开始要做的事情总会期待很高，定的目标也太高，导致往往很难开启或者进行下去，后来把难度降低了，事情却进行得更顺利和自然。</p><p>当我正在桌子上闲坐的时候，（按道理无聊的时候我应该是打开dota），很没理由地抽出压在书堆最底的 趣学Haskell，也很不按常理的开始读这本荒废的书。 重拾的荒废的书，还有一本，大话设计模式，这是本该是大学看完的书，呃呃呃，晚看好过不看吧。不过编程的书总是很讨厌，不能一看到底，经常要花很多时间去消化，害我快看了两个月才看到结尾的章节。所以当我看小说的时候，总是很有成就感，因为刷刷刷，就好几章了。</p><p>好吧，加上月中才开始学习reactive cocoa（这需要些时间去适应），响应式和函数式编程都开始在烧我的脑。虽然看上去学习的内容挺多的，不过按每天8个工作之外的番茄计算，这些都不算啥，加班就不算咯。 </p><p>。。。。哦，最后还忘了说昨晚看的演唱会，周董在广州连开3天，本想抢第二天的票，结果抢到了第三天的，不过因祸得福的是，因为是最后一天，周董开了个加长版演唱会，哈哈哈哈哈哈。</p><p>为什么生活中会发生这么多有趣的、偶然的事，因为我玩少了很多游戏。为什么没发生更多的有趣的、偶然的事，因为我还在玩游戏。有时候，做我自己，我就是整个世界。好吧，低调。</p><p>最后还是要祝愿生活中无奈和陷入苦难的人们，能重新感受这个世界的自由和快乐，包括我。也希望这个世界能少些人渣，也可能包括我。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有一首挺喜欢的歌， &lt;a href=&quot;http://music.163.com/#/m/song?id=31445554&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;七月上&lt;/a&gt;, 也刚好这个月是七月。&lt;/p&gt;
    
    </summary>
    
    
      <category term="自己, 感受, 生命" scheme="http://yoursite.com/tags/%E8%87%AA%E5%B7%B1-%E6%84%9F%E5%8F%97-%E7%94%9F%E5%91%BD/"/>
    
  </entry>
  
  <entry>
    <title>travis-ci自动打包发版的优化</title>
    <link href="http://yoursite.com/2016/05/17/travis-ci%E8%87%AA%E5%8A%A8%E6%89%93%E5%8C%85%E5%8F%91%E7%89%88%E7%9A%84%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2016/05/17/travis-ci自动打包发版的优化/</id>
    <published>2016-05-17T05:18:55.000Z</published>
    <updated>2019-03-11T08:49:01.653Z</updated>
    
    <content type="html"><![CDATA[<p>其实之前很早就弄好了travis-ci自动打包和发版的流程，在使用的过程中，因为各种原因，导致travis服务器慢慢的出现error，整个流程的时间也越来越长，慢慢地又变回手工发版了。但如果能健壮自动化的流程，比手工打包还是强很多的。</p><a id="more"></a><h4 id="导致弃用的原因"><a href="#导致弃用的原因" class="headerlink" title="导致弃用的原因"></a>导致弃用的原因</h4><p>原因有好几个，首先是网络访问的问题，因为用到了cocoapods管理第三方库，travis服务器在执行pod install的时候，需要去下载对应的包，因为每个包的源都可以由库作者自己指定，所以有可能会遇到网络访问的问题。</p><p>然后是上传指令的更改，因为上传规则和第三方工具库api的修改，上传testflight的脚本，坏过好几次，烦到我直接就手动发版了。</p><p>还有其他原因，比如因为travis-ci每次都是启动一个全新模拟器，我每次打包都需要从头编译，这。。。花了我很多时间去调试，后来烦了就手动发版好了。</p><h4 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h4><h5 id="1、网络问题，更改下载源"><a href="#1、网络问题，更改下载源" class="headerlink" title="1、网络问题，更改下载源"></a>1、网络问题，更改下载源</h5><p>每一个第三方库其实都对应着一个.podspec.json的文件，文件描述里该库的所有基本信息，这个文件可以在本地安装好cocoapods的~/.cocoapods/repos/master/Specs目录下相应的库里找到，也可以在cocoapods的<a href="https://github.com/CocoaPods/Specs/tree/master/Specs" target="_blank" rel="noopener">github库</a>中找到。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"AVOSCloud"</span>,</span><br><span class="line">    <span class="attr">"version"</span>: <span class="string">"3.2.8"</span>,</span><br><span class="line">    <span class="attr">"platforms"</span>: &#123;</span><br><span class="line">        <span class="attr">"ios"</span>: <span class="string">"6.0"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"summary"</span>: <span class="string">"LeanCloud iOS SDK for mobile backend."</span>,</span><br><span class="line">    <span class="attr">"homepage"</span>: <span class="string">"https://leancloud.cn"</span>,</span><br><span class="line">    <span class="attr">"documentation_url"</span>: <span class="string">"https://leancloud.cn/api-docs/iOS/index.html"</span>,</span><br><span class="line">    <span class="attr">"license"</span>: &#123;</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"Commercial"</span>,</span><br><span class="line">        <span class="attr">"text"</span>: <span class="string">"Copyright 2015 LeanCloud, Inc. See https://leancloud.cn/terms.html"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"authors"</span>: &#123;</span><br><span class="line">        <span class="attr">"LeanCloud"</span>: <span class="string">"support@leancloud.cn"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"source"</span>: &#123;</span><br><span class="line">        <span class="attr">"http"</span>: <span class="string">"https://download.leancloud.cn/sdk/iOS/release-v3.2.8/Static/AVOSCloud.framework.zip"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"source_files"</span>: <span class="string">"*.h"</span>,</span><br><span class="line">    <span class="attr">"public_header_files"</span>: <span class="string">"*.h"</span>,</span><br><span class="line">    <span class="attr">"preserve_paths"</span>: <span class="string">"iOS/release-v3.2.8/Static/AVOSCloud.framework/AVOSCloud"</span>,</span><br><span class="line">    <span class="attr">"vendored_libraries"</span>: <span class="string">"libAVOSCloud.a"</span>,</span><br><span class="line">    <span class="attr">"frameworks"</span>: [</span><br><span class="line">        <span class="string">"CFNetwork"</span>,...</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"libraries"</span>: [</span><br><span class="line">        <span class="string">"icucore"</span>,</span><br><span class="line">        <span class="string">"sqlite3"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"xcconfig"</span>: &#123;</span><br><span class="line">        <span class="attr">"OTHER_LDFLAGS"</span>: <span class="string">"$(inherited) -ObjC -lz"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"prepare_command"</span>: <span class="string">"cp iOS/release-v3.2.8/Static/AVOSCloud.framework/AVOSCloud libAVOSCloud.a\ncp iOS/release-v3.2.8/Static/AVOSCloud.framework/Headers/* ."</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的source就是该库的下载地址，文件的其他字段和规则，详细可以查看cocoapods的官方文档，通过改动这个地址，加快travis-ci下载该库的速度，具体步骤就是下载这个地址的东西，然后放在某个文件服务器，再把对应的地址替换掉，我是把包直接托管在github仓库上，为每个库创建一个分支，然后打一个对应版本的tag，通过这个tag就可以拿到对应版本的第三方库了。改完这个文件之后，我们又不是作者，怎么让它生效呢？这时候需要修改项目的podfile文件，<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pod 'AVOSCloud', :podspec =&gt; 'BRPodsHelp/AVOSCloud.podspec.json'</span><br><span class="line">pod 'AVOSCloudIM', :podspec =&gt; 'BRPodsHelp/AVOSCloudIM.podspec.json'</span><br></pre></td></tr></table></figure></p><p>让pod指定到本地podspec.json的地址，而对应的这个本地文件可以跟随仓库一起提交，这样维护起来就方便多了。至此，解决了网络问题。</p><h5 id="2、脚本问题"><a href="#2、脚本问题" class="headerlink" title="2、脚本问题"></a>2、脚本问题</h5><p>顺便把各个步骤用到的脚本简单说下，具体的话，还是要先了解对应工具和命令的用法</p><h6 id="compile"><a href="#compile" class="headerlink" title="compile"></a>compile</h6><p>使用xctool编译出xcachive格式的包，为啥使用xctool，因为它log很有可读性。</p><h6 id="sign签名"><a href="#sign签名" class="headerlink" title="sign签名"></a>sign签名</h6><p>这个命令有点烦，testflight的包，我是用xcodebuild中，带有-exportOptionsPlist选项的命令去完成打包的<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcodebuild -exportArchive -archivePath "$OUTPUTDIR_BUILD/$APPNAME.xcarchive" -exportPath "$OUTPUTDIR_BUILD" -exportOptionsPlist "scripts/$CONFIG.plist"</span><br></pre></td></tr></table></figure></p><p>而inhouse的包，我是使用<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcodebuild -exportArchive -archivePath "$OUTPUTDIR_BUILD/$APPNAME.xcarchive" -exportPath "$OUTPUTDIR_BUILD/$APPNAME.ipa" -exportFormat ipa -exportProvisioningProfile "$PROFILE_NAME_INH_REAL_NAME" -configuration "$CONFIG_INHOUSE"</span><br></pre></td></tr></table></figure></p><p>为啥inhouse和testflight的sign命令不同？因为坑爹苹果咯，我尝试了很多次，inhouse只有这样才能打包并且安装成功</p><h6 id="上传脚本"><a href="#上传脚本" class="headerlink" title="上传脚本"></a>上传脚本</h6><p>第三方：选择不同的分发平台，就有不同的上传脚本，这块还是参照你所选用的分发分发平台吧。<br>testflight：fastlane的credentials、pilot， 都是fastlane家的东西，github一下就有了，前者用来授权后者用来上传</p><p>自此，之前弃用travis的两个问题都解决了。</p><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>完成上面的东西，整个流程应该就能跑通了，但是，我总不能打个tag就编译和签名app-store版本和inhouse版本，并且还分发到第三方平台和testflight吧，整个过程起码1个多小时，而且不能按需打包总是很怪。所以我就把按需的需求，放在了tag上面</p><h5 id="tag支持按需打包"><a href="#tag支持按需打包" class="headerlink" title="tag支持按需打包"></a>tag支持按需打包</h5><p>这是什么鬼，其实就是判断tag是要打inhouse包，还是打testflight包咯，因为travis-ci可以拿到当前的tag，所以还是有可行性的。最后我选用-pgy和-testflight，分别表示上传到蒲公英和testflight，打tag的时候，比如1.0.1build1-pgy，这样就表示要上传蒲公英了。脚本如下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">STRING_A="$TRAVIS_TAG"</span><br><span class="line">STRING_B="$PGY_TAG"</span><br><span class="line">STRING_C="$TEST_FLIGHT_TAG"</span><br><span class="line">if [[ $&#123;STRING_A/$&#123;STRING_B&#125;//&#125; == $STRING_A ]]</span><br><span class="line">then</span><br><span class="line">    if [[ $&#123;STRING_A/$&#123;STRING_C&#125;//&#125; == $STRING_A ]]</span><br><span class="line">    then</span><br><span class="line">        exit 0</span><br><span class="line">    else</span><br><span class="line">        /#这里是testflight</span><br><span class="line">    fi</span><br><span class="line">else</span><br><span class="line">    /#这里是pgy</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p><p>if语句的原理就是stringA去掉stringB之后，是否等于stringA，等于的话，说明不包含这个命令，不等于的话，就说明包含咯。以此实现按需编译打包上传发版的需求。</p><h5 id="自动打tag"><a href="#自动打tag" class="headerlink" title="自动打tag"></a>自动打tag</h5><p>启动一个定时任务去自动打包并发版，这样就能有效率的迭代和测试。定时任务我用的是leancloud的后台云函数，支持Cron表达式的定时任务，语言用的是js，具体就是node.js。用node.js的<a href="https://github.com/request/request" target="_blank" rel="noopener">require</a>模块去调用<a href="https://developer.github.com/v3/repos/releases/#create-a-release" target="_blank" rel="noopener">github release api</a>，具体用法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> request = <span class="built_in">require</span>(<span class="string">"request"</span>);</span><br><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">    method: <span class="string">'POST'</span>,</span><br><span class="line">    url: <span class="string">'https://api.github.com/repos/beautifulreading/rio-ios/releases'</span>,</span><br><span class="line">    headers: &#123; </span><br><span class="line">        <span class="string">'cache-control'</span>: <span class="string">'no-cache'</span>,</span><br><span class="line">        <span class="string">'content-type'</span>: <span class="string">'application/json'</span>,</span><br><span class="line">        <span class="string">'user-agent'</span>: <span class="string">'node.js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    body: &#123;   </span><br><span class="line">        tag_name: <span class="string">"name"</span>,</span><br><span class="line">        target_commitish: <span class="string">'develop'</span>,</span><br><span class="line">        name: <span class="string">"name"</span>,</span><br><span class="line">        body: <span class="string">"name"</span>,</span><br><span class="line">        draft: <span class="literal">false</span>,</span><br><span class="line">        prerelease: <span class="literal">false</span> </span><br><span class="line">    &#125;,</span><br><span class="line">    json: <span class="literal">true</span> </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">request(options, <span class="function"><span class="keyword">function</span> (<span class="params">error, res, body</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (error) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(error);</span><br><span class="line">    <span class="built_in">console</span>.log(body);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>记得在headers加上认证信息， 这样每天早上6点发一个inhouse，每周发两个testflight，有点爽，不要问为啥要早上6点发，因为5点的时候程序猿还没睡觉。</p><h5 id="上传dsym文件"><a href="#上传dsym文件" class="headerlink" title="上传dsym文件"></a>上传dsym文件</h5><p>之前做的上传流程，只管上传包，却没有管dsym文件，这样要分析错误还要回头去找个tag，然后重新打包再拿出来，烦到。。。崩溃监控我们现在用的是腾讯的bugly，好处就是他只需要上传几m的dsym包，当然这个包是经过bugly的脚本处理过的，比起平时几十m，还是很有优势的。而他的处理脚本，也都被我放进仓库里，直接打包后处理。  本来是想travis直接上传到bugly对应版本的，但是bugly的api有点烦，需要的参数太多，以至于很难自动化，所以我就直接把这个处理过的dsym文件上传到github对应的release tag上，在tarvis的yml文件加上：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  provider: releases</span><br><span class="line">  api-key: "key"</span><br><span class="line">  file:</span><br><span class="line">    - "$PWD/buglydsym.zip"</span><br><span class="line">    - "$OUTPUTDIR_BUILD/$APPNAME.ipa"</span><br><span class="line">  skip_cleanup: true</span><br><span class="line">  on:</span><br><span class="line">    tags: true</span><br><span class="line">    all_branches: true</span><br></pre></td></tr></table></figure></p><p>注意yml文件是区分缩进的，这样要分析bug的时候，就从对应tag下载这个文件，然后手动传到bugly。在这里我顺便把ipa包也传上github，也好做个备份吧。</p><h5 id="travis命令支持"><a href="#travis命令支持" class="headerlink" title="travis命令支持"></a>travis命令支持</h5><p>除了以上这些之外，我们还可以用travis-ci支持的指令去使保证整个过程更加顺利，比如retry，在yml的命令后面加上 -retry=3，这样在命令失败的情况下，travis会重新执行，3代表次数。具体还是看文档吧，还有其他可选项来保证整个流程的执行。 不过有时，自动化还是会失败的😂，毕竟是机器，x因素又比较多。</p><p>好吧，travis的优化大概就结束了，接下来要继续完善持续集成，让项目的迭代和质量更好咯。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实之前很早就弄好了travis-ci自动打包和发版的流程，在使用的过程中，因为各种原因，导致travis服务器慢慢的出现error，整个流程的时间也越来越长，慢慢地又变回手工发版了。但如果能健壮自动化的流程，比手工打包还是强很多的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="travis, 慢, 打包, 发版, 优化" scheme="http://yoursite.com/tags/travis-%E6%85%A2-%E6%89%93%E5%8C%85-%E5%8F%91%E7%89%88-%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>感受真正的热爱</title>
    <link href="http://yoursite.com/2016/05/17/%E6%84%9F%E5%8F%97%E7%9C%9F%E6%AD%A3%E7%9A%84%E7%83%AD%E7%88%B1/"/>
    <id>http://yoursite.com/2016/05/17/感受真正的热爱/</id>
    <published>2016-05-17T02:52:03.000Z</published>
    <updated>2019-03-11T08:49:01.653Z</updated>
    
    <content type="html"><![CDATA[<p>我向往热爱，因为我不曾拥有热爱。<br><a id="more"></a></p><p>自从我知道朋友圈是可以关闭的之后，我就关了，减少社交和碎片的时间，让我更生活在自己的世界里，专注和惬意了很多，不过少了个信息来源，以至于我在妹纸的提醒下才知道有百鸟朝凤这部片(我当时也不知道是什么片)，然后就屁颠颠去看了。</p><p>看得过程中一直以为游天鸣是故事主线、主角，慢慢地看到后面才发现原来主线一直是焦三爷，故事从很多方面描绘出焦三爷对唢呐的热爱，焦三爷用“把唢呐吹到骨头缝里”来形容游天鸣，而他自己却是把唢呐当做自己的魂。</p><p>电影有很多感人的镜头，幼年游天鸣因为蓝玉能练习唢呐自己却不能，负气出走，回来后师父把自己以前的唢呐放在椅子上给他，当时镜头里的游天鸣，应该是每个人某个时刻的自己。后面还有挺多有感触的地方。</p><p>有两个地方，跟我之前看过的不太一样，第一处是游家班第一次接活之后，师徒两人喝酒的时候有一段特写，镜头拉得非常近，动作应该是慢了下来，带有醉意的焦三爷像小孩一样吹着唢呐，那是一种唢呐和人融为一体的效果，焦三爷就是唢呐，这应该是热爱的最高境界了。当时我心里有些许恐惧，近距离特写了一段，我以为焦三爷要死了😂， 其实后面是醉倒了，没有死，自此，我就认为这部片的主线应该是焦三爷了。后面还有很多情节，能真真切切感受焦三爷对唢呐的热爱。</p><p>第二处是焦三爷死后，天鸣在坟前给他吹起百鸟朝凤，然后焦三爷(灵魂之类的)，转身一步步地走了，每一步都是实实在在的那种，伴随着唢呐声，每一步都是真实的、真正的热爱。</p><p>这部电影还有很多值得去思考和感受的，电影之外也有很多事情可以关注，但让我感受到真正的热爱，让我也尝试去拥有这份热爱，这就是这部电影带给我的价值吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我向往热爱，因为我不曾拥有热爱。&lt;br&gt;
    
    </summary>
    
    
      <category term="百鸟朝凤, 热爱, 固执" scheme="http://yoursite.com/tags/%E7%99%BE%E9%B8%9F%E6%9C%9D%E5%87%A4-%E7%83%AD%E7%88%B1-%E5%9B%BA%E6%89%A7/"/>
    
  </entry>
  
  <entry>
    <title>自己糊弄自己</title>
    <link href="http://yoursite.com/2016/04/03/%E8%87%AA%E5%B7%B1%E7%B3%8A%E5%BC%84%E8%87%AA%E5%B7%B1/"/>
    <id>http://yoursite.com/2016/04/03/自己糊弄自己/</id>
    <published>2016-04-03T16:23:59.000Z</published>
    <updated>2019-03-11T08:49:01.653Z</updated>
    
    <content type="html"><![CDATA[<p>当我写完下面这些内容的时候，我发现两个重要的问题，首先，我的解决方案并不能解决我所谓的安全问题。然后，travis的加密工具本身就已经跟源仓库地址有绑定了，就是即使拿到加密后的代码，不在源仓库里面读取的话，是读取不到的。真的是一个滑稽的晚上，权当在练习markdown语法好了，再次说明在通宵的情况下，智商会达到下限，尤其是本来智商就不高。睡觉！</p><a id="more"></a><hr><p>以下作废</p><h4 id="网上的方法"><a href="#网上的方法" class="headerlink" title="网上的方法"></a>网上的方法</h4><p>当我还在为我能想到用travis来自动发布hexo博客的时候，心里是十分激动的。没想到网上一搜一堆，github上一搜也一堆，额，只能承认是自己落后了，哈哈哈哈哈。我一开始就按着这个博客来配置我的发布项目，<a href="http://lotabout.me/2016/Hexo-Auto-Deploy-to-Github/?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="noopener">Hexo 自动部署到 Github</a>，关键的配置文件是这样的：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">before_script:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">npm</span> <span class="string">install</span> <span class="bullet">-g</span> <span class="string">hexo</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">git</span> <span class="string">config</span> <span class="bullet">--global</span> <span class="string">user.name</span> <span class="string">'DW via Travis CI'</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">git</span> <span class="string">config</span> <span class="bullet">--global</span> <span class="string">user.email</span> <span class="string">'questions@davidwesst.com'</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">sed</span> <span class="bullet">-i''</span> <span class="string">"s~git@github.com:davidwesst/dw-blog.git~https://$&#123;GH_TOKEN&#125;:x-oauth-basic@github.com/davidwesst/dw-blog.git~"</span> <span class="string">_config.yml</span></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">hexo</span> <span class="string">generate</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">hexo</span> <span class="string">deploy</span> <span class="bullet">--silent</span></span><br></pre></td></tr></table></figure></p><h4 id="发现问题"><a href="#发现问题" class="headerlink" title="发现问题"></a>发现问题</h4><p>基本网上的配置方法都是上面所说的，代码中的${GH_TOKEN}用来读取一个叫做GH_TOKEN的变量值，你并不能直接看到这个变量的初始化代码，因为它已经加密了，假如别人能拿到这个值，加上email和name，就能往对应的git仓库签代码，所以某天你的博客出现了xxx图片，xxx片源，额，就洗不清了。但如果这是个公开的库，那么对这个值加密并没有什么显著的效果，因为人家一句echo ${GH_TOKEN} 就能把这个值给跑出来了。</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>加密一个变量是没用的，我的想法是在加载这部分关键代码之前，加上一个验证码，而这个验证码是不能暴露在公开库代码中的，并且验证的判断代码和这几行关键代码是不能拆开的，因为一旦能拆开，那么拿到这个公开库的时候删去这部分验证代码就又gg了。</p><h4 id="具体的方法"><a href="#具体的方法" class="headerlink" title="具体的方法"></a>具体的方法</h4><p>一开始我是在寻找travis中有什么全局变量是跟特定仓库有关的，如果有，用这个值就可以达到不暴露又能验证的效果。很遗憾，翻遍travis的文档，并没有发现有这样的变量，但是发现可以自己设置一个不签入仓库的变量的方法，在<a href="https://docs.travis-ci.com/user/environment-variables/" target="_blank" rel="noopener">这篇文档</a>中，有如下图红框的设置方法：<br><img src="http://ac-wdxn9gtr.clouddn.com/c0f6cb0ba9d7a5a5.travis设置变量" alt="环境变量"><br>通过这样我们就可以设置一个不暴露的key了，然后通过加密文件的方法，把验证码判断和关键代码写在同一个文件并且加密就可以达到不拆分的效果</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当我写完下面这些内容的时候，我发现两个重要的问题，首先，我的解决方案并不能解决我所谓的安全问题。然后，travis的加密工具本身就已经跟源仓库地址有绑定了，就是即使拿到加密后的代码，不在源仓库里面读取的话，是读取不到的。真的是一个滑稽的晚上，权当在练习markdown语法好了，再次说明在通宵的情况下，智商会达到下限，尤其是本来智商就不高。睡觉！&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>自动发布的blog</title>
    <link href="http://yoursite.com/2016/04/02/%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83%E7%9A%84blog/"/>
    <id>http://yoursite.com/2016/04/02/自动发布的blog/</id>
    <published>2016-04-02T23:04:05.000Z</published>
    <updated>2019-03-11T08:49:01.653Z</updated>
    
    <content type="html"><![CDATA[<p>这是一篇由iPad pro创建和编辑的小日志，使用hexo博客引擎，commit并push到github后，travis会自动生成和部署</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这是一篇由iPad pro创建和编辑的小日志，使用hexo博客引擎，commit并push到github后，travis会自动生成和部署&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>忘记备份的结果</title>
    <link href="http://yoursite.com/2016/04/02/%E5%BF%98%E8%AE%B0%E5%A4%87%E4%BB%BD%E7%9A%84%E7%BB%93%E6%9E%9C/"/>
    <id>http://yoursite.com/2016/04/02/忘记备份的结果/</id>
    <published>2016-04-02T18:04:05.000Z</published>
    <updated>2019-03-11T08:49:01.653Z</updated>
    
    <content type="html"><![CDATA[<p>忘记备份生成hexo的源文件了，导致重装系统后之前的文章都没了，然后想到了一个很挫的方法：把线上的网页转换成图片，保存了下来。<br><a id="more"></a></p><h5 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h5><p>首先介绍一个Safari的截图插件，这次截取整个网页的任务就是它完成的，名字叫做 <a href="https://safari-extensions.apple.com/details/?id=com.diigo.safari.awesomescreenshot-5DXNM3K2CT" target="_blank" rel="noopener">Awesome Screenshot</a>。<br>接下来为了节约github的免费空间，我把图片上传到了LeanCloud的一个自建应用里面，然后再写下这篇文章，就完成了。</p><h5 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h5><p>消失的<a href="http://ac-wdxn9gtr.clouddn.com/b42429503f806510.找到一个更信服的注释理由和一个更好的注释方式" target="_blank" rel="noopener">第一篇</a>，记了某次感想。<br>消失的<a href="http://ac-wdxn9gtr.clouddn.com/560fcd41025fdf75.让世界更美好" target="_blank" rel="noopener">第二篇</a>，这是在看完<a href="https://movie.douban.com/subject/25662329/" target="_blank" rel="noopener">疯狂动物城</a>之后写的。因为有几个评论，哈哈哈，所以我截了整个网页。</p><p>好了，悲剧的恢复工作算完成了，这下写完每一篇blog之后，都把整个库往github提交下，done！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;忘记备份生成hexo的源文件了，导致重装系统后之前的文章都没了，然后想到了一个很挫的方法：把线上的网页转换成图片，保存了下来。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
